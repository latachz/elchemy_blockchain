
>>>>elm/Blockchain.elm
module Blockchain exposing (..)

import Elchemy exposing (..)


type Encoding
    = Sha256



{- Elchemy doesn't have verify for IOData yet -}
{- flag noverify:+hash -}


hash : Encoding -> String -> String
hash =
    ffi ":crypto" "hash"


encode : String -> String
encode =
    ffi "Base" "encode32"



------------------------- Imports ------------------------


type alias Block =
    { index : Int
    , timestamp : Int
    , data : String
    , previousHash : String
    , difficulty : Int
    , nonce : Int
    , hash : String
    }


findValid : String -> String -> Int -> ( Int, String )
findValid start subblock nonce =
    subblock
        ++ toString nonce
        |> hash Sha256
        |> encode
        |> (\a ->
                if String.startsWith start a then
                    Debug.log "Found" ( nonce, a )
                else
                    findValid start subblock <| nonce + 1
           )


getHash : Int -> Int -> String -> String -> Int -> ( Int, String )
getHash index timestamp data previousHash difficulty =
    let
        start =
            String.repeat difficulty "WENDE"
                |> String.left difficulty

        subblock =
            toString index
                ++ toString timestamp
                ++ data
                ++ previousHash
    in
        findValid start subblock 0


block : Int -> Int -> String -> String -> Int -> Block
block index timestamp data previousHash difficulty =
    let
        ( nonce, validHash ) =
            getHash index timestamp data previousHash difficulty
    in
        Block index timestamp data previousHash difficulty nonce validHash


genesis : Int -> Block
genesis now =
    block 0 now "Genesis Block" "0" 1


new : Int -> String -> Int -> List Block -> List Block
new now data difficulty list =
    case list of
        [] ->
            let
                g =
                    genesis now
            in
                block (g.index + 1) now data g.hash difficulty :: [ g ]

        x :: xs ->
            block (x.index + 1) now data x.hash difficulty :: x :: xs
>>>>elm-stuff/packages/wende/elchemy-core/0.4.39/elm/Elchemy/XBasics.elm
module Elchemy.XBasics
    exposing
        ( Order(..)
        , compare
        , xor
        , negate
        , sqrt
        , clamp
        , logBase
        , e
        , pi
        , cos
        , sin
        , tan
        , acos
        , asin
        , atan
        , atan2
        , round
        , floor
        , ceiling
        , truncate
        , toFloat
        , toString
        , (++)
        , identity
        , always
        , flip
        , tuple2
        , tuple3
        , tuple4
        , tuple5
        )

{-| Tons of useful functions that get imported by default.
@docs compare, xor, sqrt, clamp, compare , xor , negate , sqrt , logBase , e , pi , cos , sin , tan , acos , asin , atan , atan2 , round , floor , ceiling , truncate , toFloat , toString , (++) , identity , always, flip, tuple2, tuple3, tuple4, tuple5

@docs Order

-}

import Elchemy exposing (..)


{-| Represents the relative ordering of two things.
The relations are less than, equal to, and greater than.
-}
type Order
    = LT
    | EQ
    | GT



-- Operators
{- ex

   import Kernel, except: [
     {:'++', 2},
     {:round, 1},
     {:to_string, 1}

   ]

   curry ==/2
   curry !=/2
   curry </2
   curry >/2
   curry <=/2
   curry >=/2
   curry max/2
   curry min/2

   curry &&/2
   curry ||/2

   curry +/2
   curry -/2
   curry */2
   curry //2
   curry div/2
   curry rem/2
   curry abs/1
   # Inlined from not
   curry !/1

-}


{-| Basic compare function


### Example

    compare 1 2 == LT

-}
compare : comparable -> comparable -> Order
compare a b =
    if a > b then
        GT
    else if a < b then
        LT
    else
        EQ



{- ex
   # >> is replaced with >>> by the compiler
   def l >>> r do
     fn x -> r.(l.(x)) end
   end

-}
-- not/1 is inlined by the compiler


{-| The exclusive-or operator. `True` if exactly one input is `True`.
-}
xor : Bool -> Bool -> Bool
xor a b =
    (a && not b) || (not a && b)


{-| Negate a number.

    negate 42 == -42
    negate -42 == 42
    negate 0 == 0

-}
negate : number -> number
negate =
    ffi "Kernel" "-"


{-| Take the square root of a number.
-}
sqrt : number -> Float
sqrt =
    ffi ":math" "sqrt"


{-| Clamps a number within a given range. With the expression
`clamp 100 200 x` the results are as follows:
100 if x < 100
x if 100 <= x < 200
200 if 200 <= x
-}
clamp : comparable -> comparable -> comparable -> comparable
clamp x bottom top =
    x
        |> min bottom
        |> max top


{-| -}
logBase : Float -> Float -> Float
logBase _ _ =
    notImplemented


{-| -}
e : Float
e =
    2.71828


{-| -}
pi : Float
pi =
    ffi ":math" "pi"


{-| -}
cos : Float -> Float
cos =
    ffi ":math" "cos"


{-| -}
sin : Float -> Float
sin =
    ffi ":math" "sin"


{-| -}
tan : Float -> Float
tan =
    ffi ":math" "tan"


{-| -}
acos : Float -> Float
acos =
    ffi ":math" "acos"


{-| -}
asin : Float -> Float
asin =
    ffi ":math" "asin"


{-| -}
atan : Float -> Float
atan =
    ffi ":math" "atan"


{-| -}
atan2 : Float -> Float -> Float
atan2 =
    ffi ":math" "atan2"


{-| -}
round : Float -> Int
round =
    ffi "Kernel" "round"



{- flag noverify:+floor -}


{-| -}
floor : Float -> Int
floor x =
    ffi "Float" "floor"



{- flag noverify:+ceiling -}


{-| -}
ceiling : Float -> Int
ceiling x =
    ffi "Float" "ceil"


{-| Truncate a number, rounding towards zero.
-}
truncate : Float -> Int
truncate _ =
    notImplemented


{-| Convert an integer into a float.
-}
toFloat : Int -> Float
toFloat x =
    mul_ x 1.0


mul_ : Int -> Float -> Float
mul_ =
    ffi "Kernel" "*"


{-| Turn any kind of value into a string. When you view the resulting string
with `Text.fromString` it should look just like the value it came from.

    toString 42 == "42"
    toString [1,2] == "[1, 2]"

-}
toString : a -> String
toString a =
    inspect_ a []


type BinariesAs
    = AsBinaries
    | AsStrings


type InspectOption
    = Structs Bool
    | Binaries BinariesAs


inspect_ : a -> List InspectOption -> String
inspect_ =
    ffi "Kernel" "inspect"


{-| Put two appendable things together. This includes strings, lists, and text.

    "hello" ++ "world" == "helloworld"
    [1,1,2] ++ [3,5,8] == [1,1,2,3,5,8]

-}
(++) : appendable -> appendable -> appendable
(++) a b =
    if isBinary_ a && isBinary_ b then
        addStrings_ a b
    else
        addLists_ a b


isBinary_ : a -> Bool
isBinary_ =
    ffi "Kernel" "is_binary"



{- flag noverify:+addStrings_ -}


addStrings_ : appendable -> appendable -> appendable
addStrings_ =
    ffi "Kernel" "<>"



{- flag noverify:+addLists_ -}


addLists_ : appendable -> appendable -> appendable
addLists_ =
    ffi "Kernel" "++"


{-| Given a value, returns exactly the same value. This is called
[the identity function](http://en.wikipedia.org/wiki/Identity_function).
-}
identity : a -> a
identity a =
    a


{-| Create a function that *always* returns the same value. Useful with
functions like `map`:

    List.map (always 0) [1,2,3,4,5] == [0,0,0,0,0]
    List.map (\_ -> 0) [1,2,3,4,5] == [0,0,0,0,0]

-}
always : a -> a -> a
always a _ =
    a


{-| Flip the order of the first two arguments to a function.
-}
flip : (a -> b -> c) -> b -> a -> c
flip f a b =
    f b a



-- TODO Will be fixed with #34
{- ex
   @spec curried(({any, any} -> any)) :: ((any -> any) -> any)
   curry curried/1
   def curried(fun) do
     fn fst -> fn snd -> fun.({fst, snd}) end end
   end

   @spec uncurried(((any -> any) -> any)) :: ({any, any} -> any)
   curry uncurried/1
   def uncurried(fun) do
     fn {fst, snd} -> fun.(fst).(snd) end
   end

-}
-- We don't care for Never type
-- Additional


notImplemented : a
notImplemented =
    let
        _ =
            throw_ "Not implemented"
    in
        Debug.crash "a"


throw_ : String -> ()
throw_ =
    ffi "Kernel" "throw"


{-| -}
tuple2 : a -> b -> ( a, b )
tuple2 a b =
    ( a, b )


{-| -}
tuple3 : a -> b -> c -> ( a, b, c )
tuple3 a b c =
    ( a, b, c )


{-| -}
tuple4 : a -> b -> c -> d -> ( a, b, c, d )
tuple4 a b c d =
    ( a, b, c, d )


{-| -}
tuple5 : a -> b -> c -> d -> e -> ( a, b, c, d, e )
tuple5 a b c d e =
    ( a, b, c, d, e )
>>>>elm-stuff/packages/wende/elchemy-core/0.4.39/elm/Elchemy/XChar.elm
module Elchemy.XChar
    exposing
        ( isUpper
        , isLower
        , isDigit
        , isOctDigit
        , isHexDigit
        , toUpper
        , toLower
        , KeyCode
        , toCode
        , fromCode
        )

{-| Functions for working with characters. Character literals are enclosed in
`'a'` pair of single quotes.


# Classification

@docs isUpper, isLower, isDigit, isOctDigit, isHexDigit


# Conversion

@docs toUpper, toLower


# Key Codes

@docs KeyCode, toCode, fromCode

-}

import Elchemy exposing (..)
import Basics exposing ((+))


isBetween : Char -> Char -> Char -> Bool
isBetween low high char =
    let
        code =
            toCode char
    in
        (code >= toCode low) && (code <= toCode high)


{-| True for upper case ASCII letters.

    isUpper 'D' == True
    isUpper 'A' == True
    isUpper 'x' == False

-}
isUpper : Char -> Bool
isUpper char =
    isBetween 'A' 'Z' char


{-| True for lower case ASCII letters.

    isLower 'd' == True
    isLower 'a' == True
    isLower 'X' == False

-}
isLower : Char -> Bool
isLower char =
    isBetween 'a' 'z' char


{-| True for ASCII digits `[0-9]`.

    isDigit '1' == True
    isDigit '9' == True
    isDigit 'a' == False

-}
isDigit : Char -> Bool
isDigit char =
    isBetween '0' '9' char


{-| True for ASCII octal digits `[0-7]`.

    isOctDigit '7' == True
    isOctDigit '5' == True
    isOctDigit '9' == False

-}
isOctDigit : Char -> Bool
isOctDigit char =
    isBetween '0' '7' char


{-| True for ASCII hexadecimal digits `[0-9a-fA-F]`.

    isHexDigit 'd' == True
    isHexDigit 'D' == True
    isHexDigit 'x' == False

-}
isHexDigit : Char -> Bool
isHexDigit char =
    isDigit char || isBetween 'a' 'f' char || isBetween 'A' 'F' char


{-| Convert to upper case.

    toUpper 'a' == 'A'

-}
toUpper : Char -> Char
toUpper char =
    if isBetween 'a' 'z' char then
        (toCode char)
            |> (+) -32
            |> fromCode
    else
        char


{-| Convert to lower case.

    toLower 'A' == 'a'

-}
toLower : Char -> Char
toLower char =
    if isBetween 'A' 'Z' char then
        (toCode char)
            |> (+) 32
            |> fromCode
    else
        char



-- {-| Convert to upper case, according to any locale-specific case mappings. -}
-- toLocaleUpper : Char -> Char
-- toLocaleUpper =
--   Native.Char.toLocaleUpper
-- {-| Convert to lower case, according to any locale-specific case mappings. -}
-- toLocaleLower : Char -> Char
-- toLocaleLower =
--   Native.Char.toLocaleLower


{-| Keyboard keys can be represented as integers. These are called *key codes*.
You can use [`toCode`](#toCode) and [`fromCode`](#fromCode) to convert between
key codes and characters.
-}
type alias KeyCode =
    Int



{- flag noverify:+toCode -}


{-| Convert to key code.

    toCode 'a' == 97

-}
toCode : Char -> KeyCode
toCode char =
    naiveId1 char 0


{-| Convert from key code.

    fromCode 97 == 'a'

-}
fromCode : KeyCode -> Char
fromCode code =
    naiveId2 code 0


naiveId1 : Char -> Int -> Int
naiveId1 a b =
    ffi "Kernel" "+"


naiveId2 : Int -> Int -> Char
naiveId2 a b =
    ffi "Kernel" "+"
>>>>elm-stuff/packages/wende/elchemy-core/0.4.39/elm/Elchemy/XDebug.elm
module Elchemy.XDebug
    exposing
        ( log
        , crash
        )

{-| Module with helper functions for debugging


# Debug

@docs log, crash

-}

import Elchemy exposing (..)


type Device
    = Stdio


{-| Log to console in `title: object` format

     log "Title" (1,2,3) == (1,2,3)

-}
log : String -> a -> a
log title a =
    let
        _ =
            puts_ Stdio "#{title}: #{inspect a}"
    in
        a


puts_ : Device -> a -> a
puts_ =
    ffi "IO" "puts"



{- We don't verify since it's a macro -}
{- flag noverify:+crash -}


{-| Raise an exception to crash the runtime. Should be avoided at all
costs. Helpful for crashing at not yet implelented functionality
-}
crash : String -> a
crash =
    ffi "Kernel" "raise"
>>>>elm-stuff/packages/wende/elchemy-core/0.4.39/elm/Elchemy/XDict.elm
module Elchemy.XDict
    exposing
        ( Dict
        , empty
        , singleton
        , insert
        , update
        , isEmpty
        , get
        , remove
        , member
        , size
        , filter
        , partition
        , foldl
        , foldr
        , map
        , union
        , intersect
        , diff
        , merge
        , keys
        , values
        , toList
        , fromList
        )

{-| A dictionary mapping unique keys to values. The keys can be any comparable
type. This includes `Int`, `Float`, `Time`, `Char`, `String`, and tuples or
lists of comparable types.

Insert, remove, and query operations all take *O(log n)* time.


# Dictionaries

@docs Dict


# Build

@docs empty, singleton, insert, update, remove


# Query

@docs isEmpty, member, get, size


# Lists

@docs keys, values, toList, fromList


# Transform

@docs map, foldl, foldr, filter, partition


# Combine

@docs union, intersect, diff, merge

-}

import Elchemy exposing (..)


{-| A dictionary of keys and values. So a `(Dict String User)` is a dictionary
that lets you look up a `String` (such as user names) and find the associated
`User`.
-}
type Dict k v
    = Dict


{-| Create an empty dictionary.
-}
empty : Dict k v
empty =
    ffi "NativeDict" "empty"


{-| Get the value associated with a key. If the key is not found, return
`Nothing`. This is useful when you are not sure if a key will be in the
dictionary.

    get "Tom"   (fromList [ ("Tom", Cat), ("Jerry", Mouse) ]) == Just Cat
    get "Jerry" (fromList [ ("Tom", Cat), ("Jerry", Mouse) ]) == Just Mouse
    get "Spike" (fromList [ ("Tom", Cat), ("Jerry", Mouse) ]) == Nothing

-}
get : comparable -> Dict comparable v -> Maybe v
get targetKey dict =
    ffi "NativeDict" "get"


{-| Determine if a key is in a dictionary.
-}
member : comparable -> Dict comparable v -> Bool
member key dict =
    case get key dict of
        Just _ ->
            True

        Nothing ->
            False


{-| Determine the number of key-value pairs in the dictionary.

    size (fromList [("a", 1), ("b", 2)]) == 2

-}
size : Dict k v -> Int
size dict =
    ffi "NativeDict" "size"


{-| Determine if a dictionary is empty.

    isEmpty empty == True

-}
isEmpty : Dict k v -> Bool
isEmpty dict =
    dict == empty


{-| Insert a key-value pair into a dictionary. Replaces value when there is
a collision.

    insert "a" 1 empty == fromList [("a", 1)] == True

-}
insert : comparable -> v -> Dict comparable v -> Dict comparable v
insert key value dict =
    ffi "NativeDict" "insert"


{-| Remove a key-value pair from a dictionary. If the key is not found,
no changes are made.

    isEmpty (remove "a" (fromList [("a", 1)])) == True

-}
remove : comparable -> Dict comparable v -> Dict comparable v
remove key dict =
    ffi "NativeDict" "remove"


{-| Update the value of a dictionary for a specific key with a given function.

    update "a" (\_ -> Just 2) (fromList [("a", 1)]) == (fromList [("a", 2)]) == True

-}
update : comparable -> (Maybe v -> Maybe v) -> Dict comparable v -> Dict comparable v
update k alter dict =
    ffi "NativeDict" "update"


{-| Create a dictionary with one key-value pair.
-}
singleton : comparable -> v -> Dict comparable v
singleton key value =
    insert key value empty



-- COMBINE


{-| Combine two dictionaries. If there is a collision, preference is given
to the first dictionary.
-}
union : Dict comparable v -> Dict comparable v -> Dict comparable v
union t1 t2 =
    foldl insert t2 t1


{-| Keep a key-value pair when its key appears in the second dictionary.
Preference is given to values in the first dictionary.
-}
intersect : Dict comparable v -> Dict comparable v -> Dict comparable v
intersect t1 t2 =
    filter (\k _ -> member k t2) t1


{-| Keep a key-value pair when its key does not appear in the second dictionary.
-}
diff : Dict comparable v -> Dict comparable v -> Dict comparable v
diff t1 t2 =
    foldl (\k _ t -> remove k t) t1 t2


{-| The most general way of combining two dictionaries. You provide three
accumulators for when a given key appears:

1.  Only in the left dictionary.
2.  In both dictionaries.
3.  Only in the right dictionary.

You then traverse all the keys from lowest to highest, building up whatever
you want.

    merge insert (flip (always insert)) insert (fromList [("a", 1), ("b", 2)]) (fromList [("b", 3), ("c", 4)]) empty == (fromList [("a", 1), ("b", 3), ("c", 4)]) == True

-}
merge :
    (comparable -> a -> result -> result)
    -> (comparable -> a -> b -> result -> result)
    -> (comparable -> b -> result -> result)
    -> Dict comparable a
    -> Dict comparable b
    -> result
    -> result
merge leftStep bothStep rightStep leftDict rightDict initialResult =
    ffi "NativeDict" "merge"



-- TRANSFORM


{-| Apply a function to all values in a dictionary.
-}
map : (comparable -> a -> b) -> Dict comparable a -> Dict comparable b
map f dict =
    ffi "NativeDict" "map"


{-| Fold over the key-value pairs in a dictionary, in order from lowest
key to highest key.
-}
foldl : (comparable -> v -> b -> b) -> b -> Dict comparable v -> b
foldl f acc dict =
    ffi "NativeDict" "foldl"


{-| Fold over the key-value pairs in a dictionary, in order from highest
key to lowest key.
-}
foldr : (comparable -> v -> b -> b) -> b -> Dict comparable v -> b
foldr f acc t =
    ffi "NativeDict" "foldr"


{-| Keep a key-value pair when it satisfies a predicate.
-}
filter : (comparable -> v -> Bool) -> Dict comparable v -> Dict comparable v
filter predicate dictionary =
    let
        add key value dict =
            if predicate key value then
                insert key value dict
            else
                dict
    in
        foldl add empty dictionary


{-| Partition a dictionary according to a predicate. The first dictionary
contains all key-value pairs which satisfy the predicate, and the second
contains the rest.
-}
partition : (comparable -> v -> Bool) -> Dict comparable v -> ( Dict comparable v, Dict comparable v )
partition predicate dict =
    let
        add key value ( t1, t2 ) =
            if predicate key value then
                ( insert key value t1, t2 )
            else
                ( t1, insert key value t2 )
    in
        foldl add ( empty, empty ) dict



-- LISTS


{-| Get all of the keys in a dictionary, sorted from lowest to highest.

    keys (fromList [(0,"Alice"),(1,"Bob")]) == [0,1]

-}
keys : Dict comparable v -> List comparable
keys dict =
    foldr (\key _ keyList -> key :: keyList) [] dict


{-| Get all of the values in a dictionary, in the order of their keys.

    values (fromList [(0,"Alice"),(1,"Bob")]) == ["Alice", "Bob"]

-}
values : Dict comparable v -> List v
values dict =
    foldr (\_ value valueList -> value :: valueList) [] dict


{-| Convert a dictionary into an association list of key-value pairs, sorted by keys.
-}
toList : Dict comparable v -> List ( comparable, v )
toList dict =
    foldr (\key value list -> ( key, value ) :: list) [] dict


{-| Convert an association list into a dictionary.
-}
fromList : List ( comparable, v ) -> Dict comparable v
fromList assocs =
    List.foldl (\( key, value ) dict -> insert key value dict) empty assocs
>>>>elm-stuff/packages/wende/elchemy-core/0.4.39/elm/Elchemy/XList.elm
module Elchemy.XList
    exposing
        ( isEmpty
        , length
        , reverse
        , member
        , head
        , tail
        , filter
        , take
        , drop
        , singleton
        , repeat
        , range
        , cons
        , (::)
        , append
        , concat
        , intersperse
        , partition
        , unzip
        , map
        , map2
        , filterMap
        , concatMap
        , indexedMap
        , foldr
        , foldl
        , sum
        , product
        , maximum
        , minimum
        , all
        , any
        , scanl
        , sort
        , sortBy
        , sortWith
        )

{-| A library for manipulating lists of values. Every value in a
list must have the same type.


# Basics

@docs isEmpty, length, reverse, member


# Sub-lists

@docs head, tail, filter, take, drop


# Putting Lists Together

@docs singleton, repeat, range, cons, (::), append, concat, intersperse


# Taking Lists Apart

@docs partition, unzip


# Mapping

@docs map, map2

If you can think of a legitimate use of `mapN` where `N` is 6 or more, please
let us know on [the list](https://groups.google.com/forum/#!forum/elm-discuss).
The current sentiment is that it is already quite error prone once you get to
4 and possibly should be approached another way.


# Special Maps

@docs filterMap, concatMap, indexedMap


# Folding

@docs foldr, foldl


# Special Folds

@docs sum, product, maximum, minimum, all, any, scanl


# Sorting

@docs sort, sortBy, sortWith

-}

import Elchemy exposing (..)


{- ex
   import Kernel, except: [{:length, 1}]
   import Elchemy.XBasics
-}


{-| Add an element to the front of a list. Pronounced *cons*.

    1 :: [2,3] == [1,2,3]
    1 :: [] == [1]

-}



{- flag nodef:+:: nocurry:+:: nospec:+:: -}


(::) : a -> List a -> List a
(::) a list =
    cons a list


{-| Add an element to the front of a list. Pronounced *cons*.

    cons 1 [2,3] == [1,2,3]
    cons 1 [] == [1]

-}
cons : a -> List a -> List a
cons a list =
    a :: list


{-| Extract the first element of a list.

    head [1,2,3] == Just 1
    head [] == Nothing

-}
head : List a -> Maybe a
head list =
    case list of
        x :: _ ->
            Just x

        [] ->
            Nothing


{-| Extract the rest of the list.

    tail [1,2,3] == Just [2,3]
    tail [] == Nothing

-}
tail : List a -> Maybe (List a)
tail list =
    case list of
        _ :: xs ->
            Just xs

        [] ->
            Nothing


{-| Determine if a list is empty.

    isEmpty [] == True

-}
isEmpty : List a -> Bool
isEmpty xs =
    case xs of
        [] ->
            True

        _ ->
            False


{-| Figure out whether a list contains a value.

    member 9 [1,2,3,4] == False
    member 4 [1,2,3,4] == True

-}
member : a -> List a -> Bool
member x xs =
    any (\a -> a == x) xs


{-| Apply a function to every element of a list.

    map sqrt [1,4,9] == [1.0,2.0,3.0]

    map not [True,False,True] == [False,True,False]

-}
map : (a -> b) -> List a -> List b
map f xs =
    foldr (\x acc -> f x :: acc) [] xs


{-| Same as `map` but the function is also applied to the index of each
element (starting at zero).

    indexedMap (,) ["Tom","Sue","Bob"] == [ (0,"Tom"), (1,"Sue"), (2,"Bob") ]

-}
indexedMap : (Int -> a -> b) -> List a -> List b
indexedMap f xs =
    map2 f (range 0 (length xs - 1)) xs


{-| Reduce a list from the left.

    foldl (::) [] [1,2,3] == [3,2,1]

-}
foldl : (a -> b -> b) -> b -> List a -> b
foldl func acc list =
    case list of
        [] ->
            acc

        x :: xs ->
            foldl func (func x acc) xs


{-| Reduce a list from the right.

    foldr (+) 0 [1,2,3] == 6

-}
foldr : (a -> b -> b) -> b -> List a -> b
foldr f start list =
    foldr_ list start f


foldr_ : List a -> b -> (a -> b -> b) -> b
foldr_ =
    ffi "List" "foldr"


{-| Reduce a list from the left, building up all of the intermediate results into a list.

    scanl (+) 0 [1,2,3,4] == [0,1,3,6,10]

-}
scanl : (a -> b -> b) -> b -> List a -> List b
scanl f b xs =
    let
        scan1 x accAcc =
            case accAcc of
                acc :: _ ->
                    f x acc :: accAcc

                [] ->
                    []
    in
        reverse (foldl scan1 [ b ] xs)


{-| Keep only elements that satisfy the predicate.

    filter (flip (%) 2 >> (==) 0) [1,2,3,4,5,6] == [2,4,6]

-}
filter : (a -> Bool) -> List a -> List a
filter pred xs =
    let
        conditionalCons front back =
            if pred front then
                front :: back
            else
                back
    in
        foldr conditionalCons [] xs


{-| Apply a function that may succeed to all values in the list, but only keep
the successes.

    filterMap (\a -> if a >= 18 then Just a else Nothing) [3, 15, 12, 18, 24] == [18, 24]

-}
filterMap : (a -> Maybe b) -> List a -> List b
filterMap f xs =
    foldr (maybeCons f) [] xs


maybeCons : (a -> Maybe b) -> a -> List b -> List b
maybeCons f mx xs =
    case f mx of
        Just x ->
            x :: xs

        Nothing ->
            xs


{-| Determine the length of a list.

    length [1,2,3] == 3

-}
length : List a -> Int
length xs =
    foldl (\_ i -> i + 1) 0 xs


{-| Reverse a list.

    reverse [1,2,3,4] == [4,3,2,1]

-}
reverse : List a -> List a
reverse list =
    foldl (::) [] list


{-| Determine if all elements satisfy the predicate.

    all (\a -> a % 2 == 0) [2,4] == True
    all (\a -> a % 2 == 0) [2,3] == False
    all (\a -> a % 2 == 0) [] == True

-}
all : (a -> Bool) -> List a -> Bool
all isOkay list =
    not (any (isOkay >> not) list)


{-| Determine if any elements satisfy the predicate.

    any (\a -> a % 2 == 0) [2,3] == True
    any (\a -> a % 2 == 0) [1,3] == False
    any (\a -> a % 2 == 0) [] == False

-}
any : (a -> Bool) -> List a -> Bool
any isOkay list =
    case list of
        [] ->
            False

        x :: xs ->
            if isOkay x then
                True
            else
                any isOkay xs


{-| Put two lists together.

    append [1,1,2] [3,5,8] == [1,1,2,3,5,8]
    append ['a','b'] ['c'] == ['a','b','c']

You can also use [the `(++)` operator](Basics#++) to append lists.

-}
append : List a -> List a -> List a
append xs ys =
    case ys of
        [] ->
            xs

        _ ->
            foldr (::) ys xs


{-| Concatenate a bunch of lists into a single list:

    concat [[1,2],[3],[4,5]] == [1,2,3,4,5]

-}
concat : List (List a) -> List a
concat lists =
    foldr append [] lists


{-| Map a given function onto a list and flatten the resulting lists.

    concatMap (range 2) [1] == concat (map (range 2) [1]) == True

-}
concatMap : (a -> List b) -> List a -> List b
concatMap f list =
    concat (map f list)


{-| Get the sum of the list elements.

    sum [1,2,3,4] == 10

-}
sum : List number -> number
sum numbers =
    foldl (+) 0 numbers


{-| Get the product of the list elements.

    product [1,2,3,4] == 24

-}
product : List number -> number
product numbers =
    foldl (*) 1 numbers


{-| Find the maximum element in a non-empty list.

    maximum [1,4,2] == Just 4
    maximum []      == Nothing

-}
maximum : List comparable -> Maybe comparable
maximum list =
    case list of
        x :: xs ->
            Just (foldl max x xs)

        _ ->
            Nothing


{-| Find the minimum element in a non-empty list.

    minimum [3,2,1] == Just 1
    minimum []      == Nothing

-}
minimum : List comparable -> Maybe comparable
minimum list =
    case list of
        x :: xs ->
            Just (foldl min x xs)

        _ ->
            Nothing


{-| Partition a list based on a predicate. The first list contains all values
that satisfy the predicate, and the second list contains all the value that do
not.

    partition (\x -> x < 3)      [0,1,2,3,4,5] == ([0,1,2], [3,4,5])
    partition (\a -> a % 2 == 0) [0,1,2,3,4,5] == ([0,2,4], [1,3,5])

-}
partition : (a -> Bool) -> List a -> ( List a, List a )
partition pred list =
    foldr (partitionStep pred) ( [], [] ) list


partitionStep : (a -> Bool) -> a -> ( List a, List a ) -> ( List a, List a )
partitionStep pred x ( trues, falses ) =
    if pred x then
        ( x :: trues, falses )
    else
        ( trues, x :: falses )


{-| Combine two lists, combining them with the given function.
If one list is longer, the extra elements are dropped.

    map2 (+) [1,2,3] [1,2,3,4] == [2,4,6]

    map2 (,) [1,2,3] ['a','b'] == [ (1,'a'), (2,'b') ]

-}
map2 : (a -> b -> result) -> List a -> List b -> List result
map2 f a b =
    zip_ a b
        |> map (uncurry f)


zip_ : List a -> List b -> List ( a, b )
zip_ =
    ffi "Enum" "zip"



-- {-|-}
-- map3 : (a -> b -> c -> result) -> List a -> List b -> List c -> List result
-- map3 =
--   Native.List.map3
-- {-|-}
-- map4 : (a -> b -> c -> d -> result) -> List a -> List b -> List c -> List d -> List result
-- map4 =
--   Native.List.map4
-- {-|-}
-- map5 : (a -> b -> c -> d -> e -> result) -> List a -> List b -> List c -> List d -> List e -> List result
-- map5 =
--   Native.List.map5


{-| Decompose a list of tuples into a tuple of lists.

    unzip (repeat 3 (0, True)) == ([0,0,0], [True,True,True])

-}
unzip : List ( a, b ) -> ( List a, List b )
unzip pairs =
    foldr unzipStep ( [], [] ) pairs


unzipStep : ( a, b ) -> ( List a, List b ) -> ( List a, List b )
unzipStep ( x, y ) ( xs, ys ) =
    ( x :: xs, y :: ys )


{-| Places the given value between all members of the given list.

    intersperse "on" ["turtles","turtles","turtles"] == ["turtles","on","turtles","on","turtles"]

-}
intersperse : a -> List a -> List a
intersperse sep xs =
    case xs of
        [] ->
            []

        hd :: tl ->
            let
                step x rest =
                    sep :: x :: rest

                spersed =
                    foldr step [] tl
            in
                hd :: spersed


{-| Take the first *n* members of a list.

    take 2 [1,2,3,4] == [1,2]

-}
take : Int -> List a -> List a
take n list =
    takeFast 0 n list


takeFast : Int -> Int -> List a -> List a
takeFast ctr n list =
    if n <= 0 then
        []
    else
        case ( n, list ) of
            ( _, [] ) ->
                list

            ( 1, x :: _ ) ->
                [ x ]

            ( 2, x :: y :: _ ) ->
                [ x, y ]

            ( 3, x :: y :: z :: _ ) ->
                [ x, y, z ]

            ( _, x :: y :: z :: w :: tl ) ->
                if ctr > 1000 then
                    x :: y :: z :: w :: takeTailRec (n - 4) tl
                else
                    x :: y :: z :: w :: takeFast (ctr + 1) (n - 4) tl

            _ ->
                list


takeTailRec : Int -> List a -> List a
takeTailRec n list =
    reverse (takeReverse n list [])


takeReverse : Int -> List a -> List a -> List a
takeReverse n list taken =
    if n <= 0 then
        taken
    else
        case list of
            [] ->
                taken

            x :: xs ->
                takeReverse (n - 1) xs (x :: taken)


{-| Drop the first *n* members of a list.

    drop 2 [1,2,3,4] == [3,4]

-}
drop : Int -> List a -> List a
drop n list =
    if n <= 0 then
        list
    else
        case list of
            [] ->
                list

            _ :: xs ->
                drop (n - 1) xs


{-| Create a list with only one element:

    singleton 1234 == [1234]
    singleton "hi" == ["hi"]

-}
singleton : a -> List a
singleton value =
    [ value ]


{-| Create a list with *n* copies of a value:

    repeat 3 0 == [0, 0, 0]

-}
repeat : Int -> a -> List a
repeat n value =
    repeatHelp [] n value


repeatHelp : List a -> Int -> a -> List a
repeatHelp result n value =
    if n <= 0 then
        result
    else
        repeatHelp (value :: result) (n - 1) value


{-| Create a list of numbers, every element increasing by one.
You give the lowest and highest number that should be in the list.

    range 3 6 == [3, 4, 5, 6]
    range 3 3 == [3]
    range 6 3 == []

-}
range : Int -> Int -> List Int
range lo hi =
    rangeHelp lo hi []


rangeHelp : Int -> Int -> List Int -> List Int
rangeHelp lo hi list =
    if lo <= hi then
        rangeHelp lo (hi - 1) (hi :: list)
    else
        list


{-| Sort values from lowest to highest

    sort [3,1,5] == [1,3,5]

-}
sort : List comparable -> List comparable
sort xs =
    sortBy identity xs


{-| Sort values by a derived property. To be replaced

    sortBy (\(i, _) -> i)  [(1, "mouse"),(0, "cat")] == [(0, "cat"), (1, "mouse")]

-}
sortBy : (a -> comparable) -> List a -> List a
sortBy f list =
    sortWith (\a b -> compare (f a) (f b)) list


{-| Sort values with a custom comparison function.

    sortWith (flip compare) [1,2,3,4,5] == [5,4,3,2,1]

This is also the most general sort function, allowing you
to define any other: `sort == sortWith compare`
f

-}
sortWith : (a -> a -> Order) -> List a -> List a
sortWith f list =
    let
        exf a b =
            (f a b)
                |> (\a ->
                        case a of
                            GT ->
                                False

                            EQ ->
                                False

                            LT ->
                                True
                   )
    in
        sort_ list exf


sort_ : List a -> (a -> b -> Bool) -> List a
sort_ =
    ffi "Enum" "sort"
>>>>elm-stuff/packages/wende/elchemy-core/0.4.39/elm/Elchemy/XMaybe.elm
module Elchemy.XMaybe exposing
    ( Maybe(Just, Nothing)
    , andThen
    , map
    , map2
    , map3
    , map4
    , map5
    , withDefault
    )

{-| This library fills a bunch of important niches in Elm. A `Maybe` can help
you with optional arguments, error handling, and records with optional fields.


# Definition

@docs Maybe


# Common Helpers

@docs withDefault, map, map2, map3, map4, map5


# Chaining Maybes

@docs andThen

-}


{-| Represent values that may or may not exist. It can be useful if you have a
record field that is only filled in sometimes. Or if a function takes a value
sometimes, but does not absolutely need it.
-}
type Maybe a
    = Just a
    | Nothing


{-| Provide a default value, turning an optional value into a normal
value. This comes in handy when paired with functions like
[`Dict.get`](Dict#get) which gives back a `Maybe`.

    withDefault 100 (Just 42)   == 42
    withDefault 100 Nothing     == 100

-}
withDefault : a -> Maybe a -> a
withDefault default maybe =
    case maybe of
        Nothing ->
            default

        Just value ->
            value



{- flag
   nospec:+map
   nospec:+map2
   nospec:+map3
   nospec:+map4
   nospec:+map5
-}


{-| Transform a `Maybe` value with a given function:

    map ((+) 2) (Just 9) == Just 11
    map ((+) 2) Nothing == Nothing

-}
map : (a -> b) -> Maybe a -> Maybe b
map f maybe =
    case maybe of
        Nothing ->
            Nothing

        Just value ->
            Just (f value)


{-| Apply a function if all the arguments are `Just` a value.

    map2 (+) (Just 3) (Just 4) == Just 7
    map2 (+) (Just 3) Nothing == Nothing
    map2 (+) Nothing (Just 4) == Nothing

-}
map2 : (a -> b -> value) -> Maybe a -> Maybe b -> Maybe value
map2 func ma mb =
    case ( ma, mb ) of
        ( Just a, Just b ) ->
            Just (func a b)

        _ ->
            Nothing


{-| -}
map3 : (a -> b -> c -> value) -> Maybe a -> Maybe b -> Maybe c -> Maybe value
map3 func ma mb mc =
    case ( ma, mb, mc ) of
        ( Just a, Just b, Just c ) ->
            Just (func a b c)

        _ ->
            Nothing


{-| -}
map4 : (a -> b -> c -> d -> value) -> Maybe a -> Maybe b -> Maybe c -> Maybe d -> Maybe value
map4 func ma mb mc md =
    case ( ma, mb, mc, md ) of
        ( Just a, Just b, Just c, Just d ) ->
            Just (func a b c d)

        _ ->
            Nothing


{-| -}
map5 : (a -> b -> c -> d -> e -> value) -> Maybe a -> Maybe b -> Maybe c -> Maybe d -> Maybe e -> Maybe value
map5 func ma mb mc md me =
    case ( ma, mb, mc, md, me ) of
        ( Just a, Just b, Just c, Just d, Just e ) ->
            Just (func a b c d e)

        _ ->
            Nothing


{-| Chain together many computations that may fail. It is helpful to see its
definition:

This means we only continue with the callback if things are going well. For
example, say you need to use (`head : List Int -> Maybe Int`) to get the
first month from a `List` and then make sure it is between 1 and 12:

If `head` fails and results in `Nothing` (because the `List` was `empty`),
this entire chain of operations will short-circuit and result in `Nothing`.
If `toValidMonth` results in `Nothing`, again the chain of computations
will result in `Nothing`.

-}



{- flag nospec:+andThen -}


andThen : (a -> Maybe b) -> Maybe a -> Maybe b
andThen callback maybeValue =
    case maybeValue of
        Just value ->
            callback value

        Nothing ->
            Nothing
>>>>elm-stuff/packages/wende/elchemy-core/0.4.39/elm/Elchemy/XResult.elm
module Elchemy.XResult
    exposing
        ( Result(..)
        , withDefault
        , map
        , map2
        , map3
        , map4
        , map5
        , andThen
        , toMaybe
        , fromMaybe
        , mapError
        )

{-| A `Result` is the result of a computation that may fail. This is a great
way to manage errors in Elm.


# Type and Constructors

@docs Result


# Mapping

@docs map, map2, map3, map4, map5


# Chaining

@docs andThen


# Handling Errors

@docs withDefault, toMaybe, fromMaybe, mapError

-}

import Elchemy exposing (..)


{-| A `Result` is either `Ok` meaning the computation succeeded, or it is an
`Err` meaning that there was some failure.
-}
type Result error value
    = Ok value
    | Err error


{-| If the result is `Ok` return the value, but if the result is an `Err` then
return a given default value. The following examples try to parse integers.

    withDefault 0 (XString.toInt "123") == 123
    withDefault 0 (XString.toInt "abc") == 0

-}
withDefault : a -> Result x a -> a
withDefault def result =
    case result of
        Ok a ->
            a

        Err _ ->
            def


{-| Apply a function to a result. If the result is `Ok`, it will be converted.
If the result is an `Err`, the same error value will propagate through.

    map sqrt (Ok 4.0)          == Ok 2.0
    map sqrt (Err "bad input") == Err "bad input"

-}
map : (a -> value) -> Result x a -> Result x value
map func ra =
    case ra of
        Ok a ->
            Ok (func a)

        Err e ->
            Err e


{-| Apply a function to two results, if both results are `Ok`. If not,
the first argument which is an `Err` will propagate through.

    map2 (+) (XString.toInt "1") (XString.toInt "2") == Ok 3
    map2 (+) (XString.toInt "1") (XString.toInt "y") == Err "could not convert string 'y' to an Int"
    map2 (+) (XString.toInt "x") (XString.toInt "y") == Err "could not convert string 'x' to an Int"

-}
map2 : (a -> b -> value) -> Result x a -> Result x b -> Result x value
map2 func ra rb =
    case ( ra, rb ) of
        ( Ok a, Ok b ) ->
            Ok (func a b)

        ( Err x, _ ) ->
            Err x

        ( _, Err x ) ->
            Err x


{-| -}
map3 : (a -> b -> c -> value) -> Result x a -> Result x b -> Result x c -> Result x value
map3 func ra rb rc =
    case ( ra, rb, rc ) of
        ( Ok a, Ok b, Ok c ) ->
            Ok (func a b c)

        ( Err x, _, _ ) ->
            Err x

        ( _, Err x, _ ) ->
            Err x

        ( _, _, Err x ) ->
            Err x


{-| -}
map4 : (a -> b -> c -> d -> value) -> Result x a -> Result x b -> Result x c -> Result x d -> Result x value
map4 func ra rb rc rd =
    case ( ra, rb, rc, rd ) of
        ( Ok a, Ok b, Ok c, Ok d ) ->
            Ok (func a b c d)

        ( Err x, _, _, _ ) ->
            Err x

        ( _, Err x, _, _ ) ->
            Err x

        ( _, _, Err x, _ ) ->
            Err x

        ( _, _, _, Err x ) ->
            Err x


{-| -}
map5 : (a -> b -> c -> d -> e -> value) -> Result x a -> Result x b -> Result x c -> Result x d -> Result x e -> Result x value
map5 func ra rb rc rd re =
    case ( ra, rb, rc, rd, re ) of
        ( Ok a, Ok b, Ok c, Ok d, Ok e ) ->
            Ok (func a b c d e)

        ( Err x, _, _, _, _ ) ->
            Err x

        ( _, Err x, _, _, _ ) ->
            Err x

        ( _, _, Err x, _, _ ) ->
            Err x

        ( _, _, _, Err x, _ ) ->
            Err x

        ( _, _, _, _, Err x ) ->
            Err x


{-| Chain together a sequence of computations that may fail. It is helpful
to see its definition:

This means we only continue with the callback if things are going well. For
example, say you need to use (`toInt : String -> Result String Int`) to parse
a month and make sure it is between 1 and 12:

This allows us to come out of a chain of operations with quite a specific error
message. It is often best to create a custom type that explicitly represents
the exact ways your computation may fail. This way it is easy to handle in your
code.

-}
andThen : (a -> Result x b) -> Result x a -> Result x b
andThen callback result =
    case result of
        Ok value ->
            callback value

        Err msg ->
            Err msg


{-| Transform an `Err` value. For example, say the errors we get have too much
information:

    mapError XTuple.first (Ok (123, 1)) == Ok (123, 1)
    mapError XTuple.second (Err ("nothing", "important")) == Err "important"

-}
mapError : (x -> y) -> Result x a -> Result y a
mapError f result =
    case result of
        Ok v ->
            Ok v

        Err e ->
            Err (f e)


{-| Convert to a simpler `Maybe` if the actual error message is not needed or
you need to interact with some code that primarily uses maybes.
-}
toMaybe : Result x a -> Maybe a
toMaybe result =
    case result of
        Ok v ->
            Just v

        Err _ ->
            Nothing


{-| Convert from a simple `Maybe` to interact with some code that primarily
uses `Results`.
-}
fromMaybe : x -> Maybe a -> Result x a
fromMaybe err maybe =
    case maybe of
        Just v ->
            Ok v

        Nothing ->
            Err err
>>>>elm-stuff/packages/wende/elchemy-core/0.4.39/elm/Elchemy/XSet.elm
module Elchemy.XSet
    exposing
        ( Set
        , empty
        , singleton
        , insert
        , remove
        , isEmpty
        , member
        , size
        , foldl
        , foldr
        , map
        , filter
        , partition
        , union
        , intersect
        , diff
        , toList
        , fromList
        )

{-| A set of unique values. The values can be any comparable type. This
includes `Int`, `Float`, `Time`, `Char`, `String`, and tuples or lists
of comparable types.

Insert, remove, and query operations all take *O(log n)* time.


# Sets

@docs Set


# Build

@docs empty, singleton, insert, remove


# Query

@docs isEmpty, member, size


# Combine

@docs union, intersect, diff


# Lists

@docs toList, fromList


# Transform

@docs map, foldl, foldr, filter, partition

-}

import Dict as Dict


{-| Represents a set of unique values. So `(Set Int)` is a set of integers and
`(Set String)` is a set of strings.
-}
type Set t
    = Set_elm_builtin (Dict.Dict t ())


{-| Create an empty set.

    toList empty == []

-}
empty : Set a
empty =
    Set_elm_builtin Dict.empty


{-| Create a set with one value.

    toList (singleton 1) == [1]

-}
singleton : comparable -> Set comparable
singleton k =
    Set_elm_builtin <| Dict.singleton k ()


{-| Insert a value into a set.

    toList (insert 1 empty) == [1]

-}
insert : comparable -> Set comparable -> Set comparable
insert k (Set_elm_builtin d) =
    Set_elm_builtin <| Dict.insert k () d


{-| Remove a value from a set. If the value is not found, no changes are made.

     remove 1 (fromList [1]) == empty == True

-}
remove : comparable -> Set comparable -> Set comparable
remove k (Set_elm_builtin d) =
    Set_elm_builtin <| Dict.remove k d


{-| Determine if a set is empty.

    isEmpty empty == True

-}
isEmpty : Set a -> Bool
isEmpty (Set_elm_builtin d) =
    Dict.isEmpty d


{-| Determine if a value is in a set.

    member 1 (fromList [1]) == True
    member 0 (fromList [1]) == False

-}
member : comparable -> Set comparable -> Bool
member k (Set_elm_builtin d) =
    Dict.member k d


{-| Determine the number of elements in a set.

    size (fromList [1,2,3]) == 3

-}
size : Set a -> Int
size (Set_elm_builtin d) =
    Dict.size d


{-| Get the union of two sets. Keep all values.

    union (fromList [1,2,3]) (fromList [2,3,4]) == (fromList [1,2,3,4]) == True

-}
union : Set comparable -> Set comparable -> Set comparable
union (Set_elm_builtin d1) (Set_elm_builtin d2) =
    Set_elm_builtin <| Dict.union d1 d2


{-| Get the intersection of two sets. Keeps values that appear in both sets.
-}
intersect : Set comparable -> Set comparable -> Set comparable
intersect (Set_elm_builtin d1) (Set_elm_builtin d2) =
    Set_elm_builtin <| Dict.intersect d1 d2


{-| Get the difference between the first set and the second. Keeps values
that do not appear in the second set.
-}
diff : Set comparable -> Set comparable -> Set comparable
diff (Set_elm_builtin d1) (Set_elm_builtin d2) =
    Set_elm_builtin <| Dict.diff d1 d2


{-| Convert a set into a list, sorted from lowest to highest.
-}
toList : Set comparable -> List comparable
toList (Set_elm_builtin d) =
    Dict.keys d


{-| Convert a list into a set, removing any duplicates.
-}
fromList : List comparable -> Set comparable
fromList xs =
    List.foldl insert empty xs


{-| Fold over the values in a set, in order from lowest to highest.
-}
foldl : (comparable -> b -> b) -> b -> Set comparable -> b
foldl f b (Set_elm_builtin d) =
    Dict.foldl (\k _ b -> f k b) b d


{-| Fold over the values in a set, in order from highest to lowest.
-}
foldr : (comparable -> b -> b) -> b -> Set comparable -> b
foldr f b (Set_elm_builtin d) =
    Dict.foldr (\k _ b -> f k b) b d


{-| Map a function onto a set, creating a new set with no duplicates.
-}
map : (comparable -> comparable2) -> Set comparable -> Set comparable2
map f s =
    fromList (List.map f (toList s))


{-| Create a new set consisting only of elements which satisfy a predicate.
-}
filter : (comparable -> Bool) -> Set comparable -> Set comparable
filter p (Set_elm_builtin d) =
    Set_elm_builtin <| Dict.filter (\k _ -> p k) d


{-| Create two new sets; the first consisting of elements which satisfy a
predicate, the second consisting of elements which do not.
-}
partition : (comparable -> Bool) -> Set comparable -> ( Set comparable, Set comparable )
partition p (Set_elm_builtin d) =
    let
        ( p1, p2 ) =
            Dict.partition (\k _ -> p k) d
    in
        ( Set_elm_builtin p1, Set_elm_builtin p2 )
>>>>elm-stuff/packages/wende/elchemy-core/0.4.39/elm/Elchemy/XString.elm
module Elchemy.XString
    exposing
        ( isEmpty
        , length
        , reverse
        , repeat
        , cons
        , uncons
        , fromChar
        , append
        , concat
        , split
        , join
        , words
        , lines
        , slice
        , left
        , right
        , dropLeft
        , dropRight
        , contains
        , startsWith
        , endsWith
        , indexes
        , indices
        , toInt
        , toFloat
        , toList
        , fromList
        , toUpper
        , toLower
        , pad
        , padLeft
        , padRight
        , trim
        , trimLeft
        , trimRight
        , map
        , filter
        , foldl
        , foldr
        , any
        , all
        )

{-| A built-in representation for efficient string manipulation. String literals
are enclosed in `"double quotes"`. Strings are *not* lists of characters.


# Basics

@docs isEmpty, length, reverse, repeat


# Building and Splitting

@docs cons, uncons, fromChar, append, concat, split, join, words, lines


# Get Substrings

@docs slice, left, right, dropLeft, dropRight


# Check for Substrings

@docs contains, startsWith, endsWith, indexes, indices


# Conversions

@docs toInt, toFloat, toList, fromList


# Formatting

Cosmetic operations such as padding with extra characters or trimming whitespace.

@docs toUpper, toLower, pad, padLeft, padRight, trim, trimLeft, trimRight


# Higher-Order Functions

@docs map, filter, foldl, foldr, any, all

-}

import Elchemy exposing (..)
import Elchemy.XList as XList
import Elchemy.XTuple as XTuple


{- ex
   import Kernel, except: [
     {:length, 1},
     {:'++', 2},
     {:to_charlist, 1}

   ]
   import Elchemy.XBasics, except: [
     {:to_float, 1},
    ]
-}


{-| Determine if a string is empty.

    isEmpty "" == True
    isEmpty "the world" == False

-}
isEmpty : String -> Bool
isEmpty str =
    length str == 0


{-| Add a character to the beginning of a string.

    XString.cons 'T' "he truth is out there" == "The truth is out there"

-}
cons : Char -> String -> String
cons c str =
    fromChar c ++ str


{-| Create a string from a given character.

    fromChar 'a' == "a"

-}
fromChar : Char -> String
fromChar char =
    List.singleton char |> fromCharlist


fromCharlist : List Char -> String
fromCharlist =
    ffi ":binary" "list_to_bin"


{-| Split a non-empty string into its head and tail. This lets you
pattern match on strings exactly as you would with lists.

    uncons "abc" == Just ('a',"bc")
    uncons ""    == Nothing

-}
uncons : String -> Maybe ( Char, String )
uncons str =
    let
        ( first, rest ) =
            (splitAt_ str 1)

        realFirst =
            first |> toList
    in
        case realFirst of
            [] ->
                Nothing

            [ r ] ->
                Just ( r, rest )

            _ ->
                Nothing


splitAt_ : String -> Int -> ( String, String )
splitAt_ =
    ffi "String" "split_at"


{-| Append two strings. You can also use [the `(++)` operator](Basics#++)
to do this.

    append "butter" "fly" == "butterfly"

-}
append : String -> String -> String
append a b =
    a ++ b


{-| Concatenate many strings into one.

    concat ["never","the","less"] == "nevertheless"

-}
concat : List String -> String
concat list =
    XList.foldr (++) "" list


{-| Get the length of a string.

    length "innumerable" == 11
    length "" == 0

-}
length : String -> Int
length =
    ffi "String" "length"



{- flag nospec:+map -}


{-| Transform every character in a string

    map (\c -> if c == '/' then '.' else c) "a/b/c" == "a.b.c"

-}
map : (Char -> Char) -> String -> String
map f str =
    str
        |> toList
        |> List.map (f >> fromChar)
        |> join ""



{- flag nospec:+filter -}


{-| Keep only the characters that satisfy the predicate.

    filter ((==) '2') "R2-D2" == "22"

-}
filter : (Char -> Bool) -> String -> String
filter f str =
    str
        |> toList
        |> List.filter f
        |> List.map fromChar
        |> join ""


{-| Reverse a string.

    reverse "stressed" == "desserts"

-}
reverse : String -> String
reverse =
    ffi "String" "reverse"



{- flag nospec:+foldl -}


{-| Reduce a string from the left.

    foldl XString.cons "" "time" == "emit"

-}
foldl : (Char -> b -> b) -> b -> String -> b
foldl f acc str =
    str
        |> toList
        |> XList.foldl f acc



{- flag nospec:+foldr -}


{-| Reduce a string from the right.

    foldr XString.cons "" "time" == "time"

-}
foldr : (Char -> b -> b) -> b -> String -> b
foldr f acc str =
    str
        |> toList
        |> XList.foldr f acc


{-| Split a string using a given separator.

    split "," "cat,dog,cow"        == ["cat","dog","cow"]
    split "/" "home/evan/Desktop/" == ["home","evan","Desktop", ""]

Use [`Regex.split`](Regex#split) if you need something more flexible.

-}
split : String -> String -> List String
split pattern str =
    split_ str [ pattern ] []


type SplitOption
    = Trim Bool


split_ : String -> List String -> List SplitOption -> List String
split_ =
    ffi "String" "split"


{-| Put many strings together with a given separator.

    join "a" ["H","w","ii","n"]        == "Hawaiian"
    join " " ["cat","dog","cow"]       == "cat dog cow"
    join "/" ["home","evan","Desktop"] == "home/evan/Desktop"

-}
join : String -> List String -> String
join str list =
    join_ list str


join_ : List String -> String -> String
join_ =
    ffi "Enum" "join"


{-| Repeat a string *n* times.

    repeat 3 "ha" == "hahaha"

-}
repeat : Int -> String -> String
repeat n str =
    repeat_ str n


repeat_ : String -> Int -> String
repeat_ =
    ffi "String" "duplicate"


{-| Take a substring given a start and end index. Negative indexes
are taken starting from the *end* of the list.

    slice  7  9 "snakes on a plane!" == "on"
    slice  0  6 "snakes on a plane!" == "snakes"
    slice  0 -7 "snakes on a plane!" == "snakes on a"
    slice -6 -1 "snakes on a plane!" == "plane"

-}



-- slice 7 9 = slice 7 (9 - 7)
--                     7  2
-- slice 0 6 = slice 0 (6 - 0)
--                     0 6
-- slice 0 -7 = slice 0 (18 - 7 - 0)
--                      0  11
-- slice -6 -1 = slice ((18 - 6)) (18 - 1 - 12)
--                          12       5


slice : Int -> Int -> String -> String
slice from to str =
    let
        l =
            length str

        mirror a =
            if a < 0 then
                l + a
            else
                a

        start =
            mirror from

        len =
            (mirror to) - start
    in
        slice_ str start len


slice_ : String -> Int -> Int -> String
slice_ =
    ffi "String" "slice"


{-| Take *n* characters from the left side of a string.

    left 2 "Mulder" == "Mu"

-}
left : Int -> String -> String
left n str =
    slice 0 n str


{-| Take *n* characters from the right side of a string.

    right 2 "Scully" == "ly"

-}
right : Int -> String -> String
right n str =
    slice (negate n) (length str) str


{-| Drop *n* characters from the left side of a string.

    dropLeft 2 "The Lone Gunmen" == "e Lone Gunmen"

-}
dropLeft : Int -> String -> String
dropLeft n str =
    slice n (length str) str


{-| Drop *n* characters from the right side of a string.

    dropRight 2 "Cigarette Smoking Man" == "Cigarette Smoking M"

-}
dropRight : Int -> String -> String
dropRight n str =
    slice 0 (negate n) str


{-| Pad a string on both sides until it has a given length.

    pad 5 ' ' "1"   == "  1  "
    pad 5 ' ' "11"  == "  11 "
    pad 5 ' ' "121" == " 121 "

-}
pad : Int -> Char -> String -> String
pad n c str =
    let
        right =
            (length str + n) // 2

        left =
            n
    in
        str
            |> padRight right c
            |> padLeft left c


{-| Pad a string on the left until it has a given length.

    padLeft 5 '.' "1"   == "....1"
    padLeft 5 '.' "11"  == "...11"
    padLeft 5 '.' "121" == "..121"

-}
padLeft : Int -> Char -> String -> String
padLeft n c str =
    padLeading str n (fromChar c)


padLeading : String -> Int -> String -> String
padLeading =
    ffi "String" "pad_leading"


{-| Pad a string on the right until it has a given length.

    padRight 5 '.' "1"   == "1...."
    padRight 5 '.' "11"  == "11..."
    padRight 5 '.' "121" == "121.."

-}
padRight : Int -> Char -> String -> String
padRight n c str =
    padTrailing str n (fromChar c)


padTrailing : String -> Int -> String -> String
padTrailing =
    ffi "String" "pad_trailing"


{-| Get rid of whitespace on both sides of a string.

    trim "  hats  \n" == "hats"

-}
trim : String -> String
trim =
    ffi "String" "trim"


{-| Get rid of whitespace on the left of a string.

    trimLeft "  hats  \n" == "hats  \n"

-}
trimLeft : String -> String
trimLeft =
    ffi "String" "trim_leading"


{-| Get rid of whitespace on the right of a string.

    trimRight "  hats  \n" == "  hats"

-}
trimRight : String -> String
trimRight =
    ffi "String" "trim_trailing"


{-| Break a string into words, splitting on chunks of whitespace.

    words "How are \t you? \n Good?" == ["How","are","you?","Good?"]

-}
words : String -> List String
words s =
    ffi "String" "split"


{-| Break a string into lines, splitting on newlines.

    lines "How are you?\nGood?" == ["How are you?", "Good?"]

-}
lines : String -> List String
lines str =
    split "\n" str


{-| Convert a string to all upper case. Useful for case-insensitive comparisons
and VIRTUAL YELLING.

    toUpper "skinner" == "SKINNER"

-}
toUpper : String -> String
toUpper =
    ffi "String" "upcase"


{-| Convert a string to all lower case. Useful for case-insensitive comparisons.

    toLower "X-FILES" == "x-files"

-}
toLower : String -> String
toLower =
    ffi "String" "downcase"



{- flag nospec:+any -}


{-| Determine whether *any* characters satisfy a predicate.

    any XChar.isDigit "90210" == True
    any XChar.isDigit "R2-D2" == True
    any XChar.isDigit "heart" == False

-}
any : (Char -> Bool) -> String -> Bool
any f str =
    List.any f (toList str)



{- flag nospec:+all -}


{-| Determine whether *all* characters satisfy a predicate.

    all XChar.isDigit "90210" == True
    all XChar.isDigit "R2-D2" == False
    all XChar.isDigit "heart" == False

-}
all : (Char -> Bool) -> String -> Bool
all f str =
    List.all f (toList str)


{-| See if the second string contains the first one.

    contains "the" "theory" == True
    contains "hat" "theory" == False
    contains "THE" "theory" == False

Use [`Regex.contains`](Regex#contains) if you need something more flexible.

-}
contains : String -> String -> Bool
contains pattern str =
    contains_ str pattern


contains_ : String -> String -> Bool
contains_ =
    ffi "String" " contains?"


{-| See if the second string starts with the first one.

    startsWith "the" "theory" == True
    startsWith "ory" "theory" == False

-}
startsWith : String -> String -> Bool
startsWith prefix str =
    startsWith_ str prefix


startsWith_ : String -> String -> Bool
startsWith_ prefix str =
    ffi "String" "starts_with?"


{-| See if the second string ends with the first one.

    endsWith "the" "theory" == False
    endsWith "ory" "theory" == True

-}
endsWith : String -> String -> Bool
endsWith suffix str =
    endsWith_ str suffix


endsWith_ : String -> String -> Bool
endsWith_ =
    ffi "String" "ends_with?"


{-| Get all of the indexes for a substring in another string.

    indexes "i" "Mississippi"   == [1,4,7,10]
    indexes "ss" "Mississippi"  == [2,5]
    indexes "needle" "haystack" == []

-}
indexes : String -> String -> List Int
indexes pattern str =
    matches_ str pattern
        |> List.map XTuple.first


matches_ : String -> a -> List ( Int, String )
matches_ =
    ffi ":binary" "matches"


{-| Alias for `indexes`.
-}
indices : String -> String -> List Int
indices pattern str =
    indexes pattern str


{-| Try to convert a string into an int, failing on improperly formatted strings.

    XString.toInt "123" == Ok 123
    XString.toInt "-42" == Ok -42
    XString.toInt "3.1" == Err "could not convert string '3.1' to an Int"
    XString.toInt "31a" == Err "could not convert string '31a' to an Int"

If you are extracting a number from some raw user input, you will typically
want to use [`Result.withDefault`](Result#withDefault) to handle bad data:

    XResult.withDefault 0 (XString.toInt "42") == 42
    XResult.withDefault 0 (XString.toInt "ab") == 0

-}
toInt : String -> Result String Int
toInt str =
    case toInt_ str of
        Err "argument error" ->
            Err ("could not convert string '" ++ str ++ "' to an Int")

        e ->
            e


toInt_ : String -> Result String Int
toInt_ =
    tryFfi "String" "to_integer"


{-| Try to convert a string into a float, failing on improperly formatted strings.

    XString.toFloat "123" == Ok 123.0
    XString.toFloat "-42" == Ok -42.0
    XString.toFloat "3.1" == Ok 3.1
    XString.toFloat "31a" == Err "could not convert string '31a' to a Float"

If you are extracting a number from some raw user input, you will typically
want to use [`Result.withDefault`](Result#withDefault) to handle bad data:

    XResult.withDefault 0 (XString.toFloat "42.5") == 42.5
    XResult.withDefault 0 (XString.toFloat "cats") == 0

-}
toFloat : String -> Result String Float
toFloat str =
    let
        real =
            if contains "." str then
                str
            else
                str ++ ".0"
    in
        case toFloat_ real of
            Err "argument error" ->
                Err ("could not convert string '" ++ str ++ "' to a Float")

            e ->
                e


toFloat_ : String -> Result String Float
toFloat_ =
    tryFfi "String" "to_float"


{-| Convert a string to a list of characters.

    toList "abc" == ['a','b','c']

-}
toList : String -> List Char
toList =
    ffi "String" "to_charlist"


{-| Convert a list of characters into a String. Can be useful if you
want to create a string primarily by consing, perhaps for decoding
something.

    fromList ['a','b','c'] == "abc"

-}
fromList : List Char -> String
fromList list =
    fromCharlist list
>>>>elm-stuff/packages/wende/elchemy-core/0.4.39/elm/Elchemy/XTuple.elm
module Elchemy.XTuple exposing
    ( first
    , second
    , mapFirst
    , mapSecond
    )
{-|
Module for tuple manipulation

@docs first, second, mapFirst, mapSecond
-}

{-| Extract the first value from a tuple.

    first (3, 4) == 3
    first ("john", "doe") == "john"
 -}
first : ( a, b ) -> a
first ( fst, _ ) =
    fst


{-| Extract the second value from a tuple.

    second (3, 4) == 4
    second ("john", "doe") == "doe"
 -}
second : ( a, b ) -> b
second ( _, snd ) =
    snd



{-| Transform the first value in a tuple.

    mapFirst String.reverse ("stressed", 16) == ("desserts", 16)
    mapFirst String.length  ("stressed", 16) == (8, 16)
 -}
mapFirst : (a -> a1) -> ( a, b ) -> ( a1, b )
mapFirst f ( fst, snd ) =
    ( f fst, snd )


{-| Transform the second value in a tuple.

    mapSecond sqrt          ("stressed", 16) == ("stressed", 4.0)
    mapSecond (\x -> x + 1) ("stressed", 16) == ("stressed", 17)
 -}
mapSecond : (b -> b1) -> ( a, b ) -> ( a, b1 )
mapSecond f ( fst, snd ) =
    ( fst, f snd )
